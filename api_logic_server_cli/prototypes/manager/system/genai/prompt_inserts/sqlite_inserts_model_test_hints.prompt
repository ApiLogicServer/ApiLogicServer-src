Hints: use autonum keys (for all tables - including for link/join/junction/intersection tables), allow nulls, foreign keys, no check constraints.

Be sure to create classes, never tables.
Class names are singular, and first letter is capitalized.

If you create sum, count or formula Logic Bank rules, then you MUST create a corresponding column in the data model.

Remember that SQLite DateTime type only accepts Python datetime and date objects as input, 
this means you can not enter string attributes where a date or datetime object is expected.

Don't install additional packages.
Don't use the faker pip package.

When creating SQLAlchemy data model classes, follow these guidelines carefully:
* Use foreign key columns instead of relationship names for the data.  
* Do not specify nullable unless explicitly specified.
* Do not use unique unless explicitly specified.
* Do not use Float unless explicitly specified.
* Generate the classes ONLY.
* Do NOT generate imports.
* Do NOT generate connect statements.
* Do NOT generate engines.

Create multiple rows of test data for each table, and follow these guidelines carefully:
* Create separate objects for each test data row, not in arrays. 
* Be sure to initialize derived attributes for test data rows - including all sums and counts, but do not rely on Logic Bank,
and do not generate db.execute statements.
* Do not create arrays of test data.
* Do not create a function to load test data.  
* Do not print the test data. 
* Use double quotes " for strings.
* For test data, format dates as date(year, month, day).

Create WGResult Graphics for prompts like 'graph sales by region'.
    * use 'sales by region' to create a WGResult Graphic.sqlalchemy_query
    * Be sure to use class names, not table names
    * for example, using Northwind:
        # SQLAlchemy query for Sales by Category
        sales_by_category = (
            session.query(
                category.CategoryName,
                func.sum(order_detail.Quantity * order_detail.UnitPrice * (1 - order_detail.Discount)).label("TotalSales")
            )
            .join(product, category.Id == product.CategoryId)
            .join(order_detail, product.Id == order_detail.ProductId)
            .join(order, order_detail.OrderId == order.Id)
            .filter(order.ShippedDate.isnot(None))  # Consider only shipped orders
            .group_by(category.CategoryName)
            .order_by(func.sum(order_detail.Quantity * order_detail.UnitPrice * (1 - order_detail.Discount)).desc())
        )
