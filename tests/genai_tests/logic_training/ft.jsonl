{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Airport\",\n            \"code\": \"class Airport(Base):\\n    \\\"\\\"\\\"description: Table to store details about various airports.\\\"\\\"\\\"\\n\\n    __tablename__ = 'airport'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    city = Column(String, nullable=False)\\n    country = Column(String, nullable=False)\\n    code = Column(String(3), unique=True, nullable=False)\\n    timezone = Column(String, nullable=False)\",\n            \"description\": \"Table to store details about various airports.\",\n            \"name\": \"Airport\"\n        },\n        {\n            \"classname\": \"Airplane\",\n            \"code\": \"class Airplane(Base):\\n    \\\"\\\"\\\"description: Table to store details about airplanes, including seating capacity.\\\"\\\"\\\"\\n\\n    __tablename__ = 'airplane'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    model = Column(String, nullable=False)\\n    airline = Column(String, nullable=False)\\n    seating_capacity = Column(Integer, nullable=False)\\n    registration_number = Column(String, unique=True, nullable=False)\\n    maintenance_status = Column(String, default='active')\",\n            \"description\": \"Table to store details about airplanes, including seating capacity.\",\n            \"name\": \"Airplane\"\n        },\n        {\n            \"classname\": \"Flight\",\n            \"code\": \"class Flight(Base):\\n    \\\"\\\"\\\"description: Table to store flight details, including links to origin and destination airports.\\\"\\\"\\\"\\n\\n    __tablename__ = 'flight'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    flight_number = Column(String, nullable=False)\\n    origin_id = Column(Integer, ForeignKey('airport.id'))\\n    destination_id = Column(Integer, ForeignKey('airport.id'))\\n    departure_time = Column(DateTime, nullable=False)\\n    arrival_time = Column(DateTime, nullable=False)\\n    airplane_id = Column(Integer, ForeignKey('airplane.id'))\\n    passenger_count = Column(Integer, default=0)\",\n            \"description\": \"Table to store flight details, including links to origin and destination airports.\",\n            \"name\": \"Flight\"\n        },\n        {\n            \"classname\": \"Passenger\",\n            \"code\": \"class Passenger(Base):\\n    \\\"\\\"\\\"description: Table to store passenger details and link to the flight they are on.\\\"\\\"\\\"\\n\\n    __tablename__ = 'passenger'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    passport_number = Column(String, unique=True, nullable=False)\\n    nationality = Column(String, nullable=False)\\n    flight_id = Column(Integer, ForeignKey('flight.id'))\",\n            \"description\": \"Table to store passenger details and link to the flight they are on.\",\n            \"name\": \"Passenger\"\n        },\n        {\n            \"classname\": \"FlightStatus\",\n            \"code\": \"class FlightStatus(Base):\\n    \\\"\\\"\\\"description: Table to store dynamic statuses of flights.\\\"\\\"\\\"\\n\\n    __tablename__ = 'flight_status'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    flight_id = Column(Integer, ForeignKey('flight.id'))\\n    status = Column(String, nullable=False)\\n    timestamp = Column(DateTime, nullable=False)\\n    comment = Column(String, nullable=True)\",\n            \"description\": \"Table to store dynamic statuses of flights.\",\n            \"name\": \"FlightStatus\"\n        },\n        {\n            \"classname\": \"CrewMember\",\n            \"code\": \"class CrewMember(Base):\\n    \\\"\\\"\\\"description: Table to store crew member details.\\\"\\\"\\\"\\n\\n    __tablename__ = 'crew_member'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    position = Column(String, nullable=False)\\n    employee_id = Column(String, unique=True, nullable=False)\",\n            \"description\": \"Table to store crew member details.\",\n            \"name\": \"CrewMember\"\n        },\n        {\n            \"classname\": \"FlightCrew\",\n            \"code\": \"class FlightCrew(Base):\\n    \\\"\\\"\\\"description: Join table between flights and crew members to indicate which crew members are assigned to which flights.\\\"\\\"\\\"\\n\\n    __tablename__ = 'flight_crew'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    flight_id = Column(Integer, ForeignKey('flight.id'))\\n    crew_member_id = Column(Integer, ForeignKey('crew_member.id'))\",\n            \"description\": \"Join table between flights and crew members to indicate which crew members are assigned to which flights.\",\n            \"name\": \"FlightCrew\"\n        },\n        {\n            \"classname\": \"Ticket\",\n            \"code\": \"class Ticket(Base):\\n    \\\"\\\"\\\"description: Table to store ticket information for passengers.\\\"\\\"\\\"\\n\\n    __tablename__ = 'ticket'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    ticket_number = Column(String, unique=True, nullable=False)\\n    passenger_id = Column(Integer, ForeignKey('passenger.id'))\\n    flight_id = Column(Integer, ForeignKey('flight.id'))\\n    seat_number = Column(String, nullable=False)\\n    price = Column(Integer, nullable=False)\",\n            \"description\": \"Table to store ticket information for passengers.\",\n            \"name\": \"Ticket\"\n        },\n        {\n            \"classname\": \"Baggage\",\n            \"code\": \"class Baggage(Base):\\n    \\\"\\\"\\\"description: Table to store baggage details for passengers.\\\"\\\"\\\"\\n\\n    __tablename__ = 'baggage'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    tag_number = Column(String, unique=True, nullable=False)\\n    weight = Column(Integer, nullable=False)\\n    passenger_id = Column(Integer, ForeignKey('passenger.id'))\",\n            \"description\": \"Table to store baggage details for passengers.\",\n            \"name\": \"Baggage\"\n        },\n        {\n            \"classname\": \"Gate\",\n            \"code\": \"class Gate(Base):\\n    \\\"\\\"\\\"description: Table to store information about gates at an airport.\\\"\\\"\\\"\\n\\n    __tablename__ = 'gate'\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    gate_number = Column(String, unique=True, nullable=False)\\n    airport_id = Column(Integer, ForeignKey('airport.id'))\\n    status = Column(String, default='open')\",\n            \"description\": \"Table to store information about gates at an airport.\",\n            \"name\": \"Gate\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Flight passenger count constraint\",\n            \"description\": \"Ensure that the number of passengers on a flight does not exceed the seating capacity of the airplane.\",\n            \"use_case\": \"Enforce that a flight's passengers must be less than its airplane's seating capacity.\",\n            \"code\": \"Rule.count(derive=Flight.passenger_count, as_count_of=Passenger, child_role_name='flight')\\nRule.constraint(validate=Flight,\\n                as_condition=lambda row: row.passenger_count < row.airplane.seating_capacity,\\n                error_msg=\\\"Flight has more passengers ({row.passenger_count}) than seating capacity ({row.airplane.seating_capacity})\\\")\"\n        }\n    ],\n    \"test_data\": \"from datetime import date\\n\\nairport1 = Airport(id=1, name=\\\"Heathrow\\\", city=\\\"London\\\", country=\\\"UK\\\", code=\\\"LHR\\\", timezone=\\\"GMT\\\")\\nairport2 = Airport(id=2, name=\\\"JFK International\\\", city=\\\"New York\\\", country=\\\"USA\\\", code=\\\"JFK\\\", timezone=\\\"EST\\\")\\nairport3 = Airport(id=3, name=\\\"Haneda\\\", city=\\\"Tokyo\\\", country=\\\"Japan\\\", code=\\\"HND\\\", timezone=\\\"JST\\\")\\nairport4 = Airport(id=4, name=\\\"Charles de Gaulle\\\", city=\\\"Paris\\\", country=\\\"France\\\", code=\\\"CDG\\\", timezone=\\\"CET\\\")\\n\\nairplane1 = Airplane(id=1, model=\\\"Boeing 747\\\", airline=\\\"British Airways\\\", seating_capacity=350, registration_number=\\\"G-ABCD\\\")\\nairplane2 = Airplane(id=2, model=\\\"Airbus A320\\\", airline=\\\"Delta Airlines\\\", seating_capacity=180, registration_number=\\\"N-DEFG\\\")\\nairplane3 = Airplane(id=3, model=\\\"Boeing 777\\\", airline=\\\"All Nippon Airways\\\", seating_capacity=300, registration_number=\\\"JA-HIJK\\\")\\nairplane4 = Airplane(id=4, model=\\\"Airbus A380\\\", airline=\\\"Air France\\\", seating_capacity=550, registration_number=\\\"F-LMNO\\\")\\n\\nflight1 = Flight(id=1, flight_number=\\\"BA123\\\", origin_id=1, destination_id=2, departure_time=date(2023, 4, 25), arrival_time=date(2023, 4, 25), airplane_id=1, passenger_count=0)\\nflight2 = Flight(id=2, flight_number=\\\"DL456\\\", origin_id=2, destination_id=3, departure_time=date(2023, 4, 26), arrival_time=date(2023, 4, 27), airplane_id=2, passenger_count=0)\\nflight3 = Flight(id=3, flight_number=\\\"JL789\\\", origin_id=3, destination_id=4, departure_time=date(2023, 4, 28), arrival_time=date(2023, 4, 28), airplane_id=3, passenger_count=0)\\nflight4 = Flight(id=4, flight_number=\\\"AF101\\\", origin_id=4, destination_id=1, departure_time=date(2023, 4, 29), arrival_time=date(2023, 4, 29), airplane_id=4, passenger_count=0)\\n\\npassenger1 = Passenger(id=1, name=\\\"Alice Smith\\\", passport_number=\\\"A1234567\\\", nationality=\\\"British\\\", flight_id=1)\\npassenger2 = Passenger(id=2, name=\\\"Bob Johnson\\\", passport_number=\\\"B2345678\\\", nationality=\\\"American\\\", flight_id=1)\\npassenger3 = Passenger(id=3, name=\\\"Charlie Brown\\\", passport_number=\\\"C3456789\\\", nationality=\\\"Japanese\\\", flight_id=2)\\npassenger4 = Passenger(id=4, name=\\\"David Williams\\\", passport_number=\\\"D4567890\\\", nationality=\\\"French\\\", flight_id=3)\\n\\nflight_status1 = FlightStatus(id=1, flight_id=1, status=\\\"On Time\\\", timestamp=date(2023, 4, 25), comment=\\\"\\\")\\nflight_status2 = FlightStatus(id=2, flight_id=2, status=\\\"Delayed\\\", timestamp=date(2023, 4, 26), comment=\\\"Weather conditions\\\")\\nflight_status3 = FlightStatus(id=3, flight_id=3, status=\\\"Cancelled\\\", timestamp=date(2023, 4, 27), comment=\\\"Technical issues\\\")\\nflight_status4 = FlightStatus(id=4, flight_id=4, status=\\\"Boarding\\\", timestamp=date(2023, 4, 29), comment=\\\"\\\")\\n\\ncrew_member1 = CrewMember(id=1, name=\\\"Eve Green\\\", position=\\\"Pilot\\\", employee_id=\\\"E001\\\")\\ncrew_member2 = CrewMember(id=2, name=\\\"Frank White\\\", position=\\\"Co-pilot\\\", employee_id=\\\"F002\\\")\\ncrew_member3 = CrewMember(id=3, name=\\\"Grace Black\\\", position=\\\"Flight Attendant\\\", employee_id=\\\"G003\\\")\\ncrew_member4 = CrewMember(id=4, name=\\\"Hannah Red\\\", position=\\\"Flight Attendant\\\", employee_id=\\\"H004\\\")\\n\\nflight_crew1 = FlightCrew(id=1, flight_id=1, crew_member_id=1)\\nflight_crew2 = FlightCrew(id=2, flight_id=1, crew_member_id=3)\\nflight_crew3 = FlightCrew(id=3, flight_id=2, crew_member_id=2)\\nflight_crew4 = FlightCrew(id=4, flight_id=3, crew_member_id=4)\\n\\nticket1 = Ticket(id=1, ticket_number=\\\"TKT001\\\", passenger_id=1, flight_id=1, seat_number=\\\"12A\\\", price=500)\\nticket2 = Ticket(id=2, ticket_number=\\\"TKT002\\\", passenger_id=2, flight_id=1, seat_number=\\\"12B\\\", price=500)\\nticket3 = Ticket(id=3, ticket_number=\\\"TKT003\\\", passenger_id=3, flight_id=2, seat_number=\\\"14C\\\", price=350)\\nticket4 = Ticket(id=4, ticket_number=\\\"TKT004\\\", passenger_id=4, flight_id=3, seat_number=\\\"15D\\\", price=700)\\n\\nbaggage1 = Baggage(id=1, tag_number=\\\"BAG001\\\", weight=20, passenger_id=1)\\nbaggage2 = Baggage(id=2, tag_number=\\\"BAG002\\\", weight=22, passenger_id=2)\\nbaggage3 = Baggage(id=3, tag_number=\\\"BAG003\\\", weight=25, passenger_id=3)\\nbaggage4 = Baggage(id=4, tag_number=\\\"BAG004\\\", weight=18, passenger_id=4)\\n\\ngate1 = Gate(id=1, gate_number=\\\"A1\\\", airport_id=1, status='open')\\ngate2 = Gate(id=2, gate_number=\\\"B2\\\", airport_id=1, status='closed')\\ngate3 = Gate(id=3, gate_number=\\\"C3\\\", airport_id=2, status='open')\\ngate4 = Gate(id=4, gate_number=\\\"D4\\\", airport_id=2, status='open')\",\n    \"name\": \"Airport Management System\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Department\",\n            \"code\": \"class Department(Base):\\n    \\\"\\\"\\\"description: Table for storing department details.\\\"\\\"\\\"\\n    __tablename__ = 'departments'\\n    \\n    department_id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    budget = Column(Integer, nullable=False)\\n    salary_total = Column(Integer)  # Sum of all salaries in the department\",\n            \"description\": \"Table for storing department details.\",\n            \"name\": \"Department\"\n        },\n        {\n            \"classname\": \"Employee\",\n            \"code\": \"class Employee(Base):\\n    \\\"\\\"\\\"description: Table for storing employee details.\\\"\\\"\\\"\\n    __tablename__ = 'employees'\\n    \\n    employee_id = Column(Integer, primary_key=True, autoincrement=True)\\n    department_id = Column(Integer, ForeignKey('departments.department_id'), nullable=False)\\n    name = Column(String, nullable=False)\\n    salary = Column(Integer, nullable=False)\",\n            \"description\": \"Table for storing employee details.\",\n            \"name\": \"Employee\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"DepartmentSalaryTotal\",\n            \"description\": \"Calculates the total salaries of all employees in a department.\",\n            \"use_case\": \"Calculate sum of salaries and check against department budget.\",\n            \"code\": \"Rule.sum(derive=Department.salary_total, as_sum_of=Employee.salary)\"\n        },\n        {\n            \"name\": \"DepartmentBudgetConstraint\",\n            \"description\": \"Ensures that the total of employee salaries does not exceed department budget.\",\n            \"use_case\": \"Restrict total employee salaries to be within the department's budget.\",\n            \"code\": \"Rule.constraint(validate=Department, as_condition=lambda row: row.salary_total <= row.budget, error_msg=\\\"Department salary total ({row.salary_total}) exceeds budget ({row.budget})\\\")\"\n        }\n    ],\n    \"test_data\": \"# Department Test Data\\nfrom datetime import date\\n\\ndepartment1 = Department(department_id=1, name='HR', budget=50000, salary_total=40000)\\ndepartment2 = Department(department_id=2, name='IT', budget=70000, salary_total=60000)\\ndepartment3 = Department(department_id=3, name='Finance', budget=55000, salary_total=53000)\\ndepartment4 = Department(department_id=4, name='Operations', budget=65000, salary_total=68000)\\n\\n# Employee Test Data\\nemployee1 = Employee(employee_id=1, department_id=1, name='Alice', salary=20000)\\nemployee2 = Employee(employee_id=2, department_id=1, name='Bob', salary=20000)\\nemployee3 = Employee(employee_id=3, department_id=2, name='Charlie', salary=30000)\\nemployee4 = Employee(employee_id=4, department_id=2, name='David', salary=30000)\\nemployee5 = Employee(employee_id=5, department_id=3, name='Eve', salary=40000)\\nemployee6 = Employee(employee_id=6, department_id=3, name='Frank', salary=13000)\\nemployee7 = Employee(employee_id=7, department_id=4, name='Grace', salary=33000)\\nemployee8 = Employee(employee_id=8, department_id=4, name='Hank', salary=35000)\\n\",\n    \"name\": \"DepartmentEmployeeManagement\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Employee\",\n            \"code\": \"class Employee(Base):\\n    \\\"\\\"\\\"description: table to store employee details.\\\"\\\"\\\"\\n    __tablename__ = 'employee'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    start_date = Column(Date, nullable=False)\\n    skill_score = Column(Integer, nullable=False)  # Derived attribute\\n    experience_years = Column(Integer, nullable=False)  # Assuming we store years of service\",\n            \"description\": \"table to store employee details.\",\n            \"name\": \"Employee\"\n        },\n        {\n            \"classname\": \"Skill\",\n            \"code\": \"class Skill(Base):\\n    \\\"\\\"\\\"description: table to store different skills.\\\"\\\"\\\"\\n    __tablename__ = 'skill'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    rating = Column(Integer, nullable=False)  # Skill rating\",\n            \"description\": \"table to store different skills.\",\n            \"name\": \"Skill\"\n        },\n        {\n            \"classname\": \"EmployeeSkill\",\n            \"code\": \"class EmployeeSkill(Base):\\n    \\\"\\\"\\\"description: junction table for employees and their skills.\\\"\\\"\\\"\\n    __tablename__ = 'employee_skill'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    employee_id = Column(Integer, ForeignKey('employee.id'), nullable=False)\\n    skill_id = Column(Integer, ForeignKey('skill.id'), nullable=False)\\n    rating = Column(Integer, nullable=False)  # Derived from skill rating\",\n            \"description\": \"junction table for employees and their skills.\",\n            \"name\": \"EmployeeSkill\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Copy EmployeeSkill.rating\",\n            \"description\": \"Copies the skill rating from Skill.rating.\",\n            \"use_case\": \"EmployeeSkill.rating reflects Skill.rating.\",\n            \"code\": \"Rule.copy(derive=EmployeeSkill.rating, from_parent=Skill.rating)\"\n        },\n        {\n            \"name\": \"Formula Employee.skill_score\",\n            \"description\": \"The employee's skill score is calculated as sum of skill ratings plus twice the experience years.\",\n            \"use_case\": \"Calculates overall skill score for employee including years of service impact.\",\n            \"code\": \"Rule.formula(derive=Employee.skill_score, as_expression=lambda row: sum([es.rating for es in employee_skills]) + 2 * row.experience_years)\"\n        }\n    ],\n    \"test_data\": \"from datetime import date\\n\\n# Test Data for Employee\\nemployee_1 = Employee(id=1, name=\\\"John Doe\\\", start_date=date(2015, 6, 15), experience_years=8, skill_score=5)  # sum of skills + 2 * years\\nemployee_2 = Employee(id=2, name=\\\"Jane Smith\\\", start_date=date(2017, 4, 10), experience_years=6, skill_score=5)\\nemployee_3 = Employee(id=3, name=\\\"Emily Davis\\\", start_date=date(2018, 9, 25), experience_years=5, skill_score=4)\\nemployee_4 = Employee(id=4, name=\\\"Michael Brown\\\", start_date=date(2020, 1, 5), experience_years=3, skill_score=3)\\n\\n# Test Data for Skill\\nskill_1 = Skill(id=1, name=\\\"Python\\\", rating=5)\\nskill_2 = Skill(id=2, name=\\\"SQL\\\", rating=4)\\nskill_3 = Skill(id=3, name=\\\"Data Analysis\\\", rating=3)\\nskill_4 = Skill(id=4, name=\\\"Project Management\\\", rating=4)\\n\\n# Test Data for EmployeeSkill\\nemployee_skill_1 = EmployeeSkill(id=1, employee_id=1, skill_id=1, rating=5)\\nemployee_skill_2 = EmployeeSkill(id=2, employee_id=1, skill_id=2, rating=4)\\nemployee_skill_3 = EmployeeSkill(id=3, employee_id=2, skill_id=3, rating=3)\\nemployee_skill_4 = EmployeeSkill(id=4, employee_id=2, skill_id=4, rating=4)\",\n    \"name\": \"EmployeeSkillManagement\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Customer\",\n            \"code\": \"class Customer(Base):\\n    \\\"\\\"\\\"description: A table of customers.\\\"\\\"\\\"\\n    __tablename__ = 'customer'\\n    \\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    balance = Column(Integer, default=0)\\n    credit_limit = Column(Integer)\",\n            \"description\": \"A table of customers.\",\n            \"name\": \"Customer\"\n        },\n        {\n            \"classname\": \"Order\",\n            \"code\": \"class Order(Base):\\n    \\\"\\\"\\\"description: A table of orders for customers.\\\"\\\"\\\"\\n    __tablename__ = 'order'\\n    \\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    customer_id = Column(Integer, ForeignKey('customer.id'))\\n    amount_total = Column(Integer, default=0)\\n    date_shipped = Column(DateTime, nullable=True)\\n    notes = Column(String, nullable=True)\\n    item_count = Column(Integer, default=0)\",\n            \"description\": \"A table of orders for customers.\",\n            \"name\": \"Order\"\n        },\n        {\n            \"classname\": \"Item\",\n            \"code\": \"class Item(Base):\\n    \\\"\\\"\\\"description: A table of items within orders.\\\"\\\"\\\"\\n    __tablename__ = 'item'\\n    \\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    order_id = Column(Integer, ForeignKey('order.id'))\\n    product_id = Column(Integer, ForeignKey('product.id'))\\n    quantity = Column(Integer)\\n    unit_price = Column(Integer)\\n    amount = Column(Integer, default=0)\",\n            \"description\": \"A table of items within orders.\",\n            \"name\": \"Item\"\n        },\n        {\n            \"classname\": \"Product\",\n            \"code\": \"class Product(Base):\\n    \\\"\\\"\\\"description: A table of available products.\\\"\\\"\\\"\\n    __tablename__ = 'product'\\n    \\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    unit_price = Column(Integer)\",\n            \"description\": \"A table of available products.\",\n            \"name\": \"Product\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Declare Customer Balance Constraint\",\n            \"description\": \"Ensure customer balance does not exceed credit limit.\",\n            \"use_case\": \"Customer.balance must be less than or equal to credit_limit.\",\n            \"code\": \"Rule.constraint(validate=Customer,\\n                as_condition=lambda row: row.balance <= row.credit_limit,\\n                error_msg=\\\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\\\")\"\n        },\n        {\n            \"name\": \"Derive Customer Balance\",\n            \"description\": \"Derive the customer's balance as the sum of order amounts where not shipped.\",\n            \"use_case\": \"Customer balance is derived as the sum of order amounts where date_shipped is null.\",\n            \"code\": \"Rule.sum(derive=Customer.balance, as_sum_of=Order.amount_total,\\n         where=lambda row: row.date_shipped is None)\"\n        },\n        {\n            \"name\": \"Derive Order Amount Total\",\n            \"description\": \"Derive the order's total amount as the sum of its items' amounts.\",\n            \"use_case\": \"Order amount_total is derived as the sum of item amounts.\",\n            \"code\": \"Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\"\n        },\n        {\n            \"name\": \"Calculate Item Amount Formula\",\n            \"description\": \"Calculate item amount based on quantity and unit price.\",\n            \"use_case\": \"Item amount is calculated as quantity multiplied by unit_price.\",\n            \"code\": \"Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\"\n        },\n        {\n            \"name\": \"Copy Product Unit Price to Item\",\n            \"description\": \"Copy unit_price from Product to Item.\",\n            \"use_case\": \"Store the Item.unit_price as a copy from Product.unit_price.\",\n            \"code\": \"Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\"\n        },\n        {\n            \"name\": \"Derive Order Item Count\",\n            \"description\": \"Derive the count of items in the order.\",\n            \"use_case\": \"Order item_count is derived as the count of items.\",\n            \"code\": \"Rule.count(derive=Order.item_count, as_count_of=Item)\"\n        },\n        {\n            \"name\": \"Ensure Order Has Items Before Shipping\",\n            \"description\": \"Ensure orders have items before being shipped.\",\n            \"use_case\": \"When setting date_shipped, item_count must be > 0.\",\n            \"code\": \"Rule.constraint(validate=Order,\\n                as_condition=lambda row: row.date_shipped is not None and row.item_count > 0,\\n                error_msg=\\\"Cannot ship an order with no items.\\\")\"\n        }\n    ],\n    \"test_data\": \"from datetime import date\\n\\ncustomer1 = Customer(id=1, balance=500, credit_limit=1000)\\ncustomer2 = Customer(id=2, balance=0, credit_limit=500)\\ncustomer3 = Customer(id=3, balance=250, credit_limit=750)\\ncustomer4 = Customer(id=4, balance=0, credit_limit=300)\\n\\nproduct1 = Product(id=1, unit_price=10)\\nproduct2 = Product(id=2, unit_price=20)\\nproduct3 = Product(id=3, unit_price=15)\\nproduct4 = Product(id=4, unit_price=25)\\n\\norder1 = Order(id=1, customer_id=1, amount_total=100, date_shipped=None, item_count=3, notes='First order')\\norder2 = Order(id=2, customer_id=1, amount_total=150, date_shipped=None, item_count=2, notes='Second order')\\norder3 = Order(id=3, customer_id=2, amount_total=50, date_shipped=date(2023, 10, 1), item_count=1, notes='Third order')\\norder4 = Order(id=4, customer_id=3, amount_total=0, date_shipped=None, item_count=0, notes='Fourth order')\\n\\nitem1 = Item(id=1, order_id=1, product_id=1, quantity=5, unit_price=10, amount=50)\\nitem2 = Item(id=2, order_id=1, product_id=2, quantity=2, unit_price=20, amount=40)\\nitem3 = Item(id=3, order_id=1, product_id=3, quantity=1, unit_price=10, amount=10)\\nitem4 = Item(id=4, order_id=2, product_id=2, quantity=3, unit_price=20, amount=60)\\nitem5 = Item(id=5, order_id=2, product_id=1, quantity=1, unit_price=10, amount=10)\\nitem6 = Item(id=6, order_id=3, product_id=4, quantity=2, unit_price=25, amount=50)\",\n    \"name\": \"OrderManagementSystem\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Customer\",\n            \"code\": \"class Customer(Base):\\n    \\\"\\\"\\\"description: Represents a customer in the system.\\\"\\\"\\\"\\n    __tablename__ = 'customer'\\n\\n    id = Column(Integer, primary_key=True)\\n    name = Column(String)\\n    balance = Column(Integer, default=0)  # Must include this for sum rule\\n    credit_limit = Column(Integer)\\n\\n    def __init__(self, name, balance, credit_limit):\\n        self.name = name\\n        self.balance = balance\\n        self.credit_limit = credit_limit\",\n            \"description\": \"Represents a customer in the system.\",\n            \"name\": \"Customer\"\n        },\n        {\n            \"classname\": \"Order\",\n            \"code\": \"class Order(Base):\\n    \\\"\\\"\\\"description: Represents an order placed by a customer.\\\"\\\"\\\"\\n    __tablename__ = 'order'\\n\\n    id = Column(Integer, primary_key=True)\\n    customer_id = Column(Integer, ForeignKey('customer.id'))\\n    amount_total = Column(Integer, default=0)  # Must include this for sum rule\\n    date_shipped = Column(DateTime, nullable=True)\\n    notes = Column(String)\\n\\n    def __init__(self, customer_id, amount_total, date_shipped, notes):\\n        self.customer_id = customer_id\\n        self.amount_total = amount_total\\n        self.date_shipped = date_shipped\\n        self.notes = notes\",\n            \"description\": \"Represents an order placed by a customer.\",\n            \"name\": \"Order\"\n        },\n        {\n            \"classname\": \"Item\",\n            \"code\": \"class Item(Base):\\n    \\\"\\\"\\\"description: Represents an item in an order.\\\"\\\"\\\"\\n    __tablename__ = 'item'\\n\\n    id = Column(Integer, primary_key=True)\\n    order_id = Column(Integer, ForeignKey('order.id'))\\n    product_id = Column(Integer, ForeignKey('product.id'))\\n    quantity = Column(Integer)\\n    unit_price = Column(Integer)  # Must include this for copy rule\\n    amount = Column(Integer, default=0)  # Must include this for formula rule\\n\\n    def __init__(self, order_id, product_id, quantity, unit_price, amount):\\n        self.order_id = order_id\\n        self.product_id = product_id\\n        self.quantity = quantity\\n        self.unit_price = unit_price\\n        self.amount = amount\",\n            \"description\": \"Represents an item in an order.\",\n            \"name\": \"Item\"\n        },\n        {\n            \"classname\": \"Product\",\n            \"code\": \"class Product(Base):\\n    \\\"\\\"\\\"description: Represents a product in the system.\\\"\\\"\\\"\\n    __tablename__ = 'product'\\n\\n    id = Column(Integer, primary_key=True)\\n    name = Column(String)\\n    unit_price = Column(Integer)\\n\\n    def __init__(self, name, unit_price):\\n        self.name = name\\n        self.unit_price = unit_price\",\n            \"description\": \"Represents a product in the system.\",\n            \"name\": \"Product\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Customer Balance Constraint\",\n            \"description\": \"Ensure the customer's balance does not exceed their credit limit.\",\n            \"use_case\": \"Customer.balance <= Customer.credit_limit\",\n            \"code\": \"Rule.constraint(validate=Customer, as_condition=lambda row: row.balance <= row.credit_limit, error_msg=\\\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\\\")\"\n        },\n        {\n            \"name\": \"Customer Balance Derivation\",\n            \"description\": \"Derive the customer balance as the sum of order amounts where the date_shipped is null.\",\n            \"use_case\": \"Customer.balance = Sum(Order.amount_total where date_shipped is null)\",\n            \"code\": \"Rule.sum(derive=Customer.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\"\n        },\n        {\n            \"name\": \"Order Amount Total Derivation\",\n            \"description\": \"Derive the order amount total as the sum of item amounts.\",\n            \"use_case\": \"Order.amount_total = Sum(Item.amount)\",\n            \"code\": \"Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\"\n        },\n        {\n            \"name\": \"Item Amount Formula\",\n            \"description\": \"Calculate the item amount as quantity times unit price.\",\n            \"use_case\": \"Item.amount = quantity * unit_price\",\n            \"code\": \"Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\"\n        },\n        {\n            \"name\": \"Copy Unit Price from Product\",\n            \"description\": \"Copies the unit price from the product to the item.\",\n            \"use_case\": \"Store the Item.unit_price as a copy from Product.unit_price\",\n            \"code\": \"Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\"\n        },\n        {\n            \"name\": \"No Empty Orders\",\n            \"description\": \"Enforce that an order must have items before being shipped.\",\n            \"use_case\": \"When setting the date_shipped, there must be Items.\",\n            \"code\": \"Rule.constraint(validate=Order, as_condition=lambda row: row.amount_total > 0 or row.date_shipped is None, error_msg=\\\"Cannot ship an order without items.\\\")\"\n        }\n    ],\n    \"test_data\": \"# Customer Test Data\\ncustomer1 = Customer(name=\\\"John Doe\\\", balance=200, credit_limit=500)\\ncustomer2 = Customer(name=\\\"Jane Smith\\\", balance=0, credit_limit=300)\\ncustomer3 = Customer(name=\\\"Jim Brown\\\", balance=150, credit_limit=400)\\ncustomer4 = Customer(name=\\\"Jill White\\\", balance=350, credit_limit=600)\\n\\n# Product Test Data\\nproduct1 = Product(name=\\\"Widget A\\\", unit_price=50)\\nproduct2 = Product(name=\\\"Widget B\\\", unit_price=75)\\nproduct3 = Product(name=\\\"Gadget A\\\", unit_price=80)\\nproduct4 = Product(name=\\\"Gadget B\\\", unit_price=100)\\n\\n# Order Test Data\\norder1 = Order(customer_id=1, amount_total=100, date_shipped=None, notes=\\\"Urgent\\\")\\norder2 = Order(customer_id=2, amount_total=0, date_shipped=date(2022, 1, 10), notes=\\\"Routine\\\")\\norder3 = Order(customer_id=3, amount_total=330, date_shipped=None, notes=\\\"Backorder\\\")\\norder4 = Order(customer_id=4, amount_total=250, date_shipped=None, notes=\\\"Expedited\\\")\\n\\n# Item Test Data\\nitem1 = Item(order_id=1, product_id=1, quantity=2, unit_price=50, amount=100)\\nitem2 = Item(order_id=3, product_id=2, quantity=3, unit_price=75, amount=225)\\nitem3 = Item(order_id=4, product_id=3, quantity=1, unit_price=80, amount=80)\\nitem4 = Item(order_id=3, product_id=4, quantity=1, unit_price=100, amount=100)\",\n    \"name\": \"ECommerceSystem\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Student\",\n            \"code\": \"class Student(Base):\\n    \\\"\\\"\\\"description: This table stores information about students including their eligibility to graduate.\\\"\\\"\\\"\\n    __tablename__ = 'students'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String)\\n    can_graduate = Column(Boolean, default=False)\\n    probation_count = Column(Integer, default=0)\\n    sick_days_count = Column(Integer, default=0)\",\n            \"description\": \"This table stores information about students including their eligibility to graduate.\",\n            \"name\": \"Student\"\n        },\n        {\n            \"classname\": \"Probation\",\n            \"code\": \"class Probation(Base):\\n    \\\"\\\"\\\"description: This table records instances of probations for students.\\\"\\\"\\\"\\n    __tablename__ = 'probations'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    student_id = Column(Integer, ForeignKey('students.id'))\\n    date_issued = Column(Date)\\n    reason = Column(String)\",\n            \"description\": \"This table records instances of probations for students.\",\n            \"name\": \"Probation\"\n        },\n        {\n            \"classname\": \"SickDay\",\n            \"code\": \"class SickDay(Base):\\n    \\\"\\\"\\\"description: This table records the sick days taken by students.\\\"\\\"\\\"\\n    __tablename__ = 'sick_days'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    student_id = Column(Integer, ForeignKey('students.id'))\\n    date = Column(Date)\",\n            \"description\": \"This table records the sick days taken by students.\",\n            \"name\": \"SickDay\"\n        },\n        {\n            \"classname\": \"Rule\",\n            \"code\": \"class Rule(Base):\\n    \\\"\\\"\\\"description: This table defines rules for business logic enforcement.\\\"\\\"\\\"\\n    __tablename__ = 'rules'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    description = Column(String)\",\n            \"description\": \"This table defines rules for business logic enforcement.\",\n            \"name\": \"Rule\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Student Graduation Rule\",\n            \"description\": \"A student can be marked as can-graduate only if probation_count is less than 2 and sick_days_count is less than 100.\",\n            \"use_case\": \"Ensure students meet the conditions to graduate based on probations and sick days.\",\n            \"code\": \"Rule.constraint(validate=Student,\\n                as_condition=lambda row: row.probation_count < 2 and row.sick_days_count < 100,\\n                error_msg=\\\"Student cannot graduate due to excessive probations or sick days\\\")\"\n        },\n        {\n            \"name\": \"Probation Count Rule\",\n            \"description\": \"Derives the probation_count for a student by counting Probation instances.\",\n            \"use_case\": \"Track the number of probations a student has.\",\n            \"code\": \"Rule.count(derive=Student.probation_count, as_count_of=Probation)\"\n        },\n        {\n            \"name\": \"Sick Days Count Rule\",\n            \"description\": \"Derives the sick_days_count for a student by counting SickDay instances.\",\n            \"use_case\": \"Track the number of sick days a student has taken.\",\n            \"code\": \"Rule.count(derive=Student.sick_days_count, as_count_of=SickDay)\"\n        }\n    ],\n    \"test_data\": \"# Creating test data for Students\\nstudent1 = Student(id=1, name='John Doe', probation_count=1, sick_days_count=10, can_graduate=True)\\nstudent2 = Student(id=2, name='Jane Smith', probation_count=3, sick_days_count=95, can_graduate=False)\\nstudent3 = Student(id=3, name='Alice Johnson', probation_count=0, sick_days_count=102, can_graduate=False)\\nstudent4 = Student(id=4, name='Bob Brown', probation_count=2, sick_days_count=40, can_graduate=False)\\n\\n# Creating test data for Probations\\nprobation1 = Probation(id=1, student_id=1, date_issued=date(2020, 6, 15), reason='Late submission')\\nprobation2 = Probation(id=2, student_id=2, date_issued=date(2021, 1, 10), reason='Missed classes')\\nprobation3 = Probation(id=3, student_id=2, date_issued=date(2021, 5, 5), reason='Incomplete coursework')\\n\\n# Creating test data for Sick Days\\nsick_day1 = SickDay(id=1, student_id=1, date=date(2020, 9, 10))\\nsick_day2 = SickDay(id=2, student_id=3, date=date(2021, 3, 20))\\nsick_day3 = SickDay(id=3, student_id=4, date=date(2021, 4, 25))\\nsick_day4 = SickDay(id=4, student_id=3, date=date(2021, 6, 15))\",\n    \"name\": \"StudentProbationSickDays\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Applicant\",\n            \"code\": \"from sqlalchemy import Column, Integer, String, Boolean\\nfrom sqlalchemy.orm import declarative_base\\n\\nBase = declarative_base()\\n\\nclass Applicant(Base):\\n    \\\"\\\"\\\"\\n    description: Stores applicant information including names and hirability.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'applicant'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    first_name = Column(String)\\n    last_name = Column(String)\\n    is_hirable = Column(Boolean)\\n    felony_count = Column(Integer, default=0)  # Derived Attribute\\n    bankruptcy_count = Column(Integer, default=0)  # Derived Attribute\\n\",\n            \"description\": \"Applicant table includes first name, last name, and whether the applicant is hirable. Derived attributes track number of felonies and bankruptcies.\",\n            \"name\": \"Applicant\"\n        },\n        {\n            \"classname\": \"Felony\",\n            \"code\": \"class Felony(Base):\\n    \\\"\\\"\\\"\\n    description: Records felony details linked to applicants.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'felony'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    applicant_id = Column(Integer)  # Foreign key linking to Applicant\\n    class_of_felony = Column(Integer)  # Examples: Class 1 to 5\\n\\n\",\n            \"description\": \"Records felony information connected to each applicant through applicant_id. The class_of_felony indicates the felony type.\",\n            \"name\": \"Felony\"\n        },\n        {\n            \"classname\": \"Bankruptcy\",\n            \"code\": \"class Bankruptcy(Base):\\n    \\\"\\\"\\\"\\n    description: Records bankruptcy information linked to applicants.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'bankruptcy'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    applicant_id = Column(Integer)  # Foreign key linking to Applicant\\n    filing_date = Column(String)  # Date of filing\\n\\n\",\n            \"description\": \"Captures bankruptcy records connected to applicants via applicant_id. Filing_date marks when bankruptcy was filed.\",\n            \"name\": \"Bankruptcy\"\n        },\n        {\n            \"classname\": \"ApplicantFelony\",\n            \"code\": \"class ApplicantFelony(Base):\\n    \\\"\\\"\\\"\\n    description: Junction table associating applicants with felonies.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'applicant_felony'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    applicant_id = Column(Integer)  # Foreign key linking to Applicant\\n    felony_id = Column(Integer)     # Foreign key linking to Felony\\n\\n\",\n            \"description\": \"Junction table directly linking applicants to felony records with applicant_id and felony_id.\",\n            \"name\": \"ApplicantFelony\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"BankruptcyCountRule\",\n            \"description\": \"Count number of bankruptcies per applicant.\",\n            \"use_case\": \"Applicants must have a derived attribute reflecting their total number of bankruptcies.\",\n            \"code\": \"Rule.count(derive=Applicant.bankruptcy_count, as_count_of=Bankruptcy)\"\n        },\n        {\n            \"name\": \"FelonyCountRule\",\n            \"description\": \"Count number of felonies per applicant.\",\n            \"use_case\": \"Applicants must have a derived attribute reflecting their total number of felonies.\",\n            \"code\": \"Rule.count(derive=Applicant.felony_count, as_count_of=Felony)\"\n        },\n        {\n            \"name\": \"HirabilityConstraintRule\",\n            \"description\": \"Ensure hirability rules regarding bankruptcies and felonies are enforced.\",\n            \"use_case\": \"Signal error if is-hirable is true and there are more than 3 bankruptcies, or 2 felonies.\",\n            \"code\": \"Rule.constraint(validate=Applicant,\\n                    as_condition=lambda row: not (row.is_hirable and (row.bankruptcy_count > 3 or row.felony_count > 2)),\\n                    error_msg=\\\"Applicant is not hirable with more than 3 bankruptcies or 2 felonies.\\\")\"\n        }\n    ],\n    \"test_data\": \"from datetime import date\\n\\n# Test Data for Applicant\\napplicant1 = Applicant(first_name='John', last_name='Doe', is_hirable=True, felony_count=1, bankruptcy_count=1)\\napplicant2 = Applicant(first_name='Jane', last_name='Smith', is_hirable=True, felony_count=0, bankruptcy_count=0)\\napplicant3 = Applicant(first_name='Alice', last_name='Johnson', is_hirable=False, felony_count=5, bankruptcy_count=2)\\napplicant4 = Applicant(first_name='Bob', last_name='Brown', is_hirable=True, felony_count=2, bankruptcy_count=4)\\n\\n# Test Data for Felony\\nfelony1 = Felony(applicant_id=1, class_of_felony=2)\\nfelony2 = Felony(applicant_id=3, class_of_felony=2)\\nfelony3 = Felony(applicant_id=3, class_of_felony=1)\\nfelony4 = Felony(applicant_id=3, class_of_felony=1)\\n\\n# Test Data for Bankruptcy\\nbankruptcy1 = Bankruptcy(applicant_id=1, filing_date='2023-06-15')\\nbankruptcy2 = Bankruptcy(applicant_id=4, filing_date='2022-01-20')\\nbankruptcy3 = Bankruptcy(applicant_id=4, filing_date='2021-08-23')\\nbankruptcy4 = Bankruptcy(applicant_id=4, filing_date='2020-03-10')\\n\\n# Test Data for ApplicantFelony\\napplicant_felony1 = ApplicantFelony(applicant_id=1, felony_id=1)\\napplicant_felony2 = ApplicantFelony(applicant_id=3, felony_id=2)\\napplicant_felony3 = ApplicantFelony(applicant_id=3, felony_id=3)\\napplicant_felony4 = ApplicantFelony(applicant_id=3, felony_id=4)\",\n    \"name\": \"ApplicantScreeningSystem\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Student\",\n            \"code\": \"class Student(Base):\\n    \\\"\\\"\\\"description: Stores student information including GPA and honor society eligibility status.\\\"\\\"\\\"\\n    __tablename__ = 'student'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    gpa = Column(Numeric, nullable=False)\\n    honor_society_eligible = Column(Boolean, nullable=False)\\n    club_name = Column(String)  # Copied from Club\\n    service_activity_count = Column(Integer, default=0)  # Derived based on club memberships with 'service' in name\",\n            \"description\": \"Stores student information including GPA and honor society eligibility status.\",\n            \"name\": \"student\"\n        },\n        {\n            \"classname\": \"Grade\",\n            \"code\": \"class Grade(Base):\\n    \\\"\\\"\\\"description: Stores the grades for each student.\\\"\\\"\\\"\\n    __tablename__ = 'grade'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    student_id = Column(Integer, ForeignKey('student.id'), nullable=False)\\n    subject = Column(String, nullable=False)\\n    score = Column(Numeric, nullable=False)\",\n            \"description\": \"Stores the grades for each student.\",\n            \"name\": \"grade\"\n        },\n        {\n            \"classname\": \"Club\",\n            \"code\": \"class Club(Base):\\n    \\\"\\\"\\\"description: Defines clubs that students can join.\\\"\\\"\\\"\\n    __tablename__ = 'club'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\",\n            \"description\": \"Defines clubs that students can join.\",\n            \"name\": \"club\"\n        },\n        {\n            \"classname\": \"StudentClub\",\n            \"code\": \"class StudentClub(Base):\\n    \\\"\\\"\\\"description: Represents the many-to-many relationship between students and clubs.\\\"\\\"\\\"\\n    __tablename__ = 'student_club'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    student_id = Column(Integer, ForeignKey('student.id'), nullable=False)\\n    club_id = Column(Integer, ForeignKey('club.id'), nullable=False)\",\n            \"description\": \"Represents the many-to-many relationship between students and clubs.\",\n            \"name\": \"student_club\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Copy Club Name to Student\",\n            \"description\": \"Copy the name from Club to Student Club\",\n            \"use_case\": \"Ensure that the Club name is correctly associated with each student in their respective clubs.\",\n            \"code\": \"Rule.copy(derive=Student.club_name, from_parent=Club.name)\"\n        },\n        {\n            \"name\": \"Service Activity Count\",\n            \"description\": \"The student's service activity is the count of Student Clubs where name contains 'service'.\",\n            \"use_case\": \"Calculate the number of clubs with 'service' in their name for each student.\",\n            \"code\": \"Rule.count(derive=Student.service_activity_count, as_count_of=StudentClub, where=lambda row: 'service' in row.club.name)\"\n        },\n        {\n            \"name\": \"Honor Society Eligibility Constraint\",\n            \"description\": \"Signal error if student is eligible for the honor society and their GPA is under 3.5 or they have less than 2 service activities.\",\n            \"use_case\": \"Maintain high standards for honor society eligibility.\",\n            \"code\": \"Rule.constraint(validate=Student,\\n                as_condition=lambda row: not(row.honor_society_eligible and (row.gpa < 3.5 or row.service_activity_count < 2)),\\n                error_msg=\\\"Honor Society requires GPA >= 3.5 and at least 2 service activities\\\")\"\n        }\n    ],\n    \"test_data\": \"from datetime import date, datetime\\n\\n# Create test data for Clubs\\nclub1 = Club(id=1, name='Science Club')\\nclub2 = Club(id=2, name='Service Club')\\nclub3 = Club(id=3, name='Art Club')\\nclub4 = Club(id=4, name='Debate Club')\\n\\n# Create test data for Students\\nstudent1 = Student(id=1, name='Alice', gpa=3.6, honor_society_eligible=True, club_name='Service Club', service_activity_count=1)\\nstudent2 = Student(id=2, name='Bob', gpa=3.4, honor_society_eligible=True, club_name='Art Club', service_activity_count=0)\\nstudent3 = Student(id=3, name='Charlie', gpa=3.7, honor_society_eligible=False, club_name='Science Club', service_activity_count=0)\\nstudent4 = Student(id=4, name='Diana', gpa=3.9, honor_society_eligible=True, club_name='Service Club', service_activity_count=2)\\n\\n# Create test data for Grades\\ngrade1 = Grade(id=1, student_id=1, subject='Math', score=95)\\ngrade2 = Grade(id=2, student_id=2, subject='History', score=88)\\ngrade3 = Grade(id=3, student_id=3, subject='Science', score=92)\\ngrade4 = Grade(id=4, student_id=4, subject='Art', score=98)\\n\\n# Create test data for StudentClubs\\nstudent_club1 = StudentClub(id=1, student_id=1, club_id=2)\\nstudent_club2 = StudentClub(id=2, student_id=2, club_id=3)\\nstudent_club3 = StudentClub(id=3, student_id=3, club_id=1)\\nstudent_club4 = StudentClub(id=4, student_id=4, club_id=2)\",\n    \"name\": \"StudentClubLogic\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Product\",\n            \"code\": \"from sqlalchemy import Column, Integer, Boolean, String\\nfrom sqlalchemy.ext.declarative import declarative_base\\n\\nBase = declarative_base()\\n\\nclass Product(Base):\\n    \\\"\\\"\\\"description: Represents products with orderable status.\\\"\\\"\\\"\\n    __tablename__ = 'product'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String)\\n    orderable = Column(Boolean)\\n    notice_count = Column(Integer, default=0)  # Expected to be calculated\\n    class_5_notice_count = Column(Integer, default=0)  # Expected to be calculated\",\n            \"description\": \"Represents products with orderable status.\",\n            \"name\": \"Product\"\n        },\n        {\n            \"classname\": \"Notice\",\n            \"code\": \"class Notice(Base):\\n    \\\"\\\"\\\"description: Represents notices related to products.\\\"\\\"\\\"\\n    __tablename__ = 'notice'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    product_id = Column(Integer)\\n    severity = Column(Integer)\",\n            \"description\": \"Represents notices related to products.\",\n            \"name\": \"Notice\"\n        },\n        {\n            \"classname\": \"Order\",\n            \"code\": \"class Order(Base):\\n    \\\"\\\"\\\"description: Represents customer orders.\\\"\\\"\\\"\\n    __tablename__ = 'order'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    product_id = Column(Integer)\\n    order_date = Column(Date)\",\n            \"description\": \"Represents customer orders.\",\n            \"name\": \"Order\"\n        },\n        {\n            \"classname\": \"OrderDetail\",\n            \"code\": \"class OrderDetail(Base):\\n    \\\"\\\"\\\"description: Represents detailed items in each order.\\\"\\\"\\\"\\n    __tablename__ = 'order_detail'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    order_id = Column(Integer)\\n    product_id = Column(Integer)\\n    quantity = Column(Integer)\\n    total_amount = Column(Integer, default=0)  # Expected to be calculated\",\n            \"description\": \"Represents detailed items in each order.\",\n            \"name\": \"OrderDetail\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Count Notices for Product\",\n            \"description\": \"Derive product notice count from related notices.\",\n            \"use_case\": \"Raise an error if product is orderable and there are any severity 5 Notices or more than 3 Notices.\",\n            \"code\": \"Rule.count(derive=Product.notice_count, as_count_of=Notice)\"\n        },\n        {\n            \"name\": \"Count Severity 5 Notices for Product\",\n            \"description\": \"Derive count of severity 5 notices for products.\",\n            \"use_case\": \"Raise an error if product is orderable and there are any severity 5 Notices.\",\n            \"code\": \"Rule.count(derive=Product.class_5_notice_count, as_count_of=Notice, where=lambda row: row.severity == 5)\"\n        },\n        {\n            \"name\": \"Constraint Product Orderability\",\n            \"description\": \"Ensure product is not orderable if conditions on notices are met.\",\n            \"use_case\": \"Raise an error if product is orderable and there are any severity 5 Notices or more than 3 Notices.\",\n            \"code\": \"Rule.constraint(validate=Product,\\n    as_condition=lambda row: not (row.orderable and (row.class_5_notice_count > 0 or row.notice_count > 3)),\\n    error_msg=\\\"Orderable product contains severity 5 or excessive notices.\\\")\"\n        }\n    ],\n    \"test_data\": \"from datetime import date\\n\\n# Create some products\\ntest_product_1 = Product(id=1, name='Product 1', orderable=True, notice_count=4, class_5_notice_count=1)  # Expect conflict due to notice count and severity 5 test\\n\\ntest_product_2 = Product(id=2, name='Product 2', orderable=True, notice_count=2, class_5_notice_count=0)  # Should be valid\\n\\ntest_product_3 = Product(id=3, name='Product 3', orderable=False, notice_count=5, class_5_notice_count=2)  # Should be valid\\n\\ntest_product_4 = Product(id=4, name='Product 4', orderable=True, notice_count=3, class_5_notice_count=0)  # Should be valid\\n\\n# Create notices\\nnotice_1 = Notice(id=1, product_id=1, severity=5)\\nnotice_2 = Notice(id=2, product_id=1, severity=2)\\nnotice_3 = Notice(id=3, product_id=1, severity=4)\\nnotice_4 = Notice(id=4, product_id=1, severity=1)\\n\\n# Create orders\\norder_1 = Order(id=1, product_id=1, order_date=date(2023, 10, 1))\\norder_2 = Order(id=2, product_id=2, order_date=date(2023, 10, 2))\\norder_3 = Order(id=3, product_id=3, order_date=date(2023, 10, 3))\\norder_4 = Order(id=4, product_id=4, order_date=date(2023, 10, 4))\\n\\n# Create order details\\norder_detail_1 = OrderDetail(id=1, order_id=1, product_id=1, quantity=3, total_amount=60)\\norder_detail_2 = OrderDetail(id=2, order_id=2, product_id=2, quantity=5, total_amount=100)\\norder_detail_3 = OrderDetail(id=3, order_id=3, product_id=3, quantity=2, total_amount=40)\\norder_detail_4 = OrderDetail(id=4, order_id=4, product_id=4, quantity=6, total_amount=120)\",\n    \"name\": \"ProductNoticeSystem\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Customer\",\n            \"code\": \"class Customer(Base):\\n    \\\"\\\"\\\"description: Table representing customers.\\\"\\\"\\\"\\n    __tablename__ = 'customers'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    balance = Column(Integer, default=0)\\n    credit_limit = Column(Integer)\\n\",\n            \"description\": \"Table representing customers.\",\n            \"name\": \"Customer\"\n        },\n        {\n            \"classname\": \"Order\",\n            \"code\": \"class Order(Base):\\n    \\\"\\\"\\\"description: Table representing customer orders.\\\"\\\"\\\"\\n    __tablename__ = 'orders'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    customer_id = Column(Integer, ForeignKey('customers.id'))\\n    amount_total = Column(Integer, default=0)\\n    date_shipped = Column(DateTime)\\n    item_count = Column(Integer, default=0)\\n    ready = Column(Boolean, default=False)\\n    notes = Column(String)\\n\",\n            \"description\": \"Table representing customer orders.\",\n            \"name\": \"Order\"\n        },\n        {\n            \"classname\": \"Item\",\n            \"code\": \"class Item(Base):\\n    \\\"\\\"\\\"description: Table representing items in an order.\\\"\\\"\\\"\\n    __tablename__ = 'items'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    order_id = Column(Integer, ForeignKey('orders.id'))\\n    product_id = Column(Integer, ForeignKey('products.id'))\\n    amount = Column(Integer, default=0)\\n    quantity = Column(Integer)\\n    unit_price = Column(Integer)\\n    ready = Column(Boolean, default=False)\\n\",\n            \"description\": \"Table representing items in an order.\",\n            \"name\": \"Item\"\n        },\n        {\n            \"classname\": \"Product\",\n            \"code\": \"class Product(Base):\\n    \\\"\\\"\\\"description: Table representing products available for orders.\\\"\\\"\\\"\\n    __tablename__ = 'products'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    total_ordered = Column(Integer, default=0)\\n    reorder_required = Column(Boolean, default=False)\\n    quantity_on_hand = Column(Integer)\\n\",\n            \"description\": \"Table representing products available for orders.\",\n            \"name\": \"Product\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Customer Balance Rules\",\n            \"description\": \"Logic Bank rules to enforce balance constraints and derivations for customers.\",\n            \"use_case\": \"enforce the Check Credit for ready orders.\",\n            \"code\": \"Rule.sum(derive=Customer.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None and row.ready is True);\\nRule.constraint(validate=Customer, as_condition=lambda row: row.balance <= row.credit_limit, error_msg=\\\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\\\")\"\n        },\n        {\n            \"name\": \"Order Amount Total Rule\",\n            \"description\": \"Sum the items to calculate order's total amount.\",\n            \"use_case\": \"enforce the Check Credit for ready orders.\",\n            \"code\": \"Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\"\n        },\n        {\n            \"name\": \"Item Amount Rule\",\n            \"description\": \"Calculate item amount based on quantity and unit price.\",\n            \"use_case\": \"enforce the Check Credit for ready orders.\",\n            \"code\": \"Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\"\n        },\n        {\n            \"name\": \"Copy Item Unit Price Rule\",\n            \"description\": \"Copy unit price from product to item.\",\n            \"use_case\": \"enforce the Check Credit for ready orders.\",\n            \"code\": \"Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\"\n        },\n        {\n            \"name\": \"Item Ready Rule\",\n            \"description\": \"Set item ready state based on order ready state.\",\n            \"use_case\": \"Compute Products ordered\",\n            \"code\": \"Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\"\n        },\n        {\n            \"name\": \"Product Total Ordered Rule\",\n            \"description\": \"Calculate total products ordered when ready.\",\n            \"use_case\": \"Compute Products ordered\",\n            \"code\": \"Rule.sum(derive=Product.total_ordered, as_sum_of=Item.quantity, where=lambda row: row.ready == True)\"\n        },\n        {\n            \"name\": \"Product Reorder Required Rule\",\n            \"description\": \"Determine if reorder is required based on total ordered.\",\n            \"use_case\": \"Compute Products ordered\",\n            \"code\": \"Rule.formula(derive=Product.reorder_required, as_expression=lambda row: row.quantity_on_hand <= row.total_ordered)\"\n        },\n        {\n            \"name\": \"Order Item Count Rules\",\n            \"description\": \"Count items in an order and ensure no empty orders when shipped.\",\n            \"use_case\": \"No Empty Orders\",\n            \"code\": \"Rule.count(derive=Order.item_count, as_count_of=Item);\\nRule.constraint(validate=Order, as_condition=lambda row: row.date_shipped is not None and row.item_count > 0, error_msg=\\\"Cannot ship an order with no items\\\")\"\n        }\n    ],\n    \"test_data\": \"customer1 = Customer(balance=600, credit_limit=1000)\\ncustomer2 = Customer(balance=1200, credit_limit=1500)\\ncustomer3 = Customer(balance=800, credit_limit=1000)\\ncustomer4 = Customer(balance=300, credit_limit=500)\\n\\norder1 = Order(customer_id=1, amount_total=300, date_shipped=None, item_count=2, ready=True, notes=\\\"First order\\\")\\norder2 = Order(customer_id=2, amount_total=1200, date_shipped=None, item_count=3, ready=False, notes=\\\"Pending order\\\")\\norder3 = Order(customer_id=1, amount_total=500, date_shipped=None, item_count=1, ready=True, notes=\\\"Urgent order\\\")\\norder4 = Order(customer_id=3, amount_total=0, date_shipped=None, item_count=0, ready=False, notes=\\\"No items yet\\\")\\n\\nitem1 = Item(order_id=1, product_id=1, amount=150, quantity=5, unit_price=30, ready=True)\\nitem2 = Item(order_id=2, product_id=2, amount=600, quantity=10, unit_price=60, ready=False)\\nitem3 = Item(order_id=2, product_id=3, amount=600, quantity=12, unit_price=50, ready=False)\\nitem4 = Item(order_id=3, product_id=1, amount=500, quantity=20, unit_price=25, ready=True)\\n\\nproduct1 = Product(total_ordered=25, reorder_required=True, quantity_on_hand=20)\\nproduct2 = Product(total_ordered=10, reorder_required=False, quantity_on_hand=100)\\nproduct3 = Product(total_ordered=12, reorder_required=False, quantity_on_hand=50)\\nproduct4 = Product(total_ordered=0, reorder_required=False, quantity_on_hand=75)\",\n    \"name\": \"OrderManagement\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 4 tables"}, {"role": "user", "content": "Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.Here is the simplified API for LogicBank:\n\nCreate a function called declare_logic(), consisting of calls to Rule methods.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are summed.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, child_role_name: str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            child_role_name: parent's child accessor attribute (required only for disambiguation)\n            where: optional where clause, designates which child rows are counted.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, child_role_name, insert_parent)\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  Conditions may not contains sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n    @staticmethod\n    def parent_check(validate: object,\n                     error_msg: str = \"(error_msg not provided)\",\n                     enable: bool = True):\n        \"\"\"\n        Parent Checks ensure that non-null foreign keys are present in parent class\n\n        Example\n           Rule.parent_check(validate=Customer, enable=True, error_msg=\"Missing Parent\")\n\n        Parent_check failures raise ConstraintException, e.g.:\n            try:\n                session.commit()\n            except ConstraintException as ce:\n                print(\"Constraint raised: \" + str(ce))\n\n        Args:\n            validate: name of mapped class\n            error_msg: message included in exception (can have {} syntax)\n            enable: True (default) = enable, False means disable (tolerate orphans)\n\n        Note: False not recommended - for existing databases with bad data\n            Behavior is undefined for other rules (sum, count, parent references, etc)\n\n        \"\"\"\n        return ParentCheck(validate=validate, error_msg=error_msg, enable=enable)\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking)\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate count values also require a new column, with a LogicBank count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nPrompt:\n\n    A student cannot be an honor student unless they have mre than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count > 0 or row.felony_count>3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request."}, {"role": "assistant", "content": "{\n    \"models\": [\n        {\n            \"classname\": \"Teacher\",\n            \"code\": \"class Teacher(Base):\\n    \\\"\\\"\\\"\\n    description: Stores information about teachers and their course assignments.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'teachers'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    max_courses = Column(Integer, default=5)  # Column for constraint logic\\n    course_count = Column(Integer, default=0)  # Derived by Logic Bank rules for tracking assignments\",\n            \"description\": \"Stores information about teachers and their course assignments.\",\n            \"name\": \"Teacher\"\n        },\n        {\n            \"classname\": \"Course\",\n            \"code\": \"class Course(Base):\\n    \\\"\\\"\\\"\\n    description: Contains details about courses offered.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'courses'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    teacher_id = Column(Integer, ForeignKey('teachers.id'))\\n    charge = Column(Integer, nullable=False)\\n\\n    offering_count = Column(Integer, default=0)  # Derived column to track offerings\",\n            \"description\": \"Contains details about courses offered.\",\n            \"name\": \"Course\"\n        },\n        {\n            \"classname\": \"Student\",\n            \"code\": \"class Student(Base):\\n    \\\"\\\"\\\"\\n    description: Provides student information along with their budgetary constraints.\\n    \\\"\\\"\\\"\\n    __tablename__ = 'students'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    name = Column(String, nullable=False)\\n    budget = Column(Integer, nullable=False)\\n\\n    enrollment_count = Column(Integer, default=0)  # Derived by Logic Bank rules\\n    total_charges = Column(Integer, default=0)  # Derived to check against budget\\n\",\n            \"description\": \"Provides student information along with their budgetary constraints.\",\n            \"name\": \"Student\"\n        },\n        {\n            \"classname\": \"Offering\",\n            \"code\": \"class Offering(Base):\\n    \\\"\\\"\\\"\\n    description: Manages the relationship between students and courses (enrollments).\\n    \\\"\\\"\\\"\\n    __tablename__ = 'offerings'\\n\\n    id = Column(Integer, primary_key=True, autoincrement=True)\\n    student_id = Column(Integer, ForeignKey('students.id'))\\n    course_id = Column(Integer, ForeignKey('courses.id'))\\n    charge = Column(Integer, nullable=False)  # Copied from course charge\\n\",\n            \"description\": \"Manages the relationship between students and courses (enrollments).\",\n            \"name\": \"Offering\"\n        }\n    ],\n    \"rules\": [\n        {\n            \"name\": \"Teacher Course Count Constraint\",\n            \"description\": \"Ensure teachers are not assigned to more than 5 courses.\",\n            \"use_case\": \"capacity\",\n            \"code\": \"Rule.count(derive=Teacher.course_count, as_count_of=Course, where=lambda row: row.teacher_id is not None)\\nRule.constraint(validate=Teacher,\\n                as_condition=lambda row: row.course_count <= 5,\\n                error_msg=\\\"Teacher assigned too many courses ({row.course_count}) exceeds capacity.\\\")\"\n        },\n        {\n            \"name\": \"Student Enrollment Count Constraint\",\n            \"description\": \"Ensure students do not have more enrollments than 6.\",\n            \"use_case\": \"capacity\",\n            \"code\": \"Rule.count(derive=Student.enrollment_count, as_count_of=Offering, where=lambda row: row.student_id is not None)\\nRule.constraint(validate=Student,\\n                as_condition=lambda row: row.enrollment_count <= 6,\\n                error_msg=\\\"Student has too many enrollments ({row.enrollment_count}) exceeds limit.\\\")\"\n        },\n        {\n            \"name\": \"Course Charge Copy\",\n            \"description\": \"Copy course charge to enrollment charge.\",\n            \"use_case\": \"budget control\",\n            \"code\": \"Rule.copy(derive=Offering.charge, from_parent=Course.charge)\"\n        },\n        {\n            \"name\": \"Student Budget Constraint\",\n            \"description\": \"Ensure student's total enrollment charges do not exceed their budget.\",\n            \"use_case\": \"budget control\",\n            \"code\": \"Rule.sum(derive=Student.total_charges, as_sum_of=Offering.charge)\\nRule.constraint(validate=Student,\\n                as_condition=lambda row: row.total_charges <= row.budget,\\n                error_msg=\\\"Total charges ({row.total_charges}) exceed student's budget ({row.budget}).\\\")\"\n        }\n    ],\n    \"test_data\": \"# Teachers\\nteacher1 = Teacher(name=\\\"Alice Smith\\\", course_count=3)\\nteacher2 = Teacher(name=\\\"Bob Johnson\\\", course_count=5)\\nteacher3 = Teacher(name=\\\"Charlie Brown\\\", course_count=1)\\nteacher4 = Teacher(name=\\\"Daisy Adams\\\", course_count=0)\\n\\n# Courses\\ncourse1 = Course(name=\\\"Math 101\\\", teacher_id=1, charge=100)\\ncourse2 = Course(name=\\\"Science 101\\\", teacher_id=2, charge=150)\\ncourse3 = Course(name=\\\"History 101\\\", teacher_id=1, charge=120)\\ncourse4 = Course(name=\\\"English 101\\\", teacher_id=3, charge=200)\\n\\n# Students\\nstudent1 = Student(name=\\\"Eva White\\\", budget=500, enrollment_count=4, total_charges=300)\\nstudent2 = Student(name=\\\"Frank Green\\\", budget=600, enrollment_count=2, total_charges=100)\\nstudent3 = Student(name=\\\"Grace Blue\\\", budget=700, enrollment_count=6, total_charges=450)\\nstudent4 = Student(name=\\\"Henry Red\\\", budget=300, enrollment_count=1, total_charges=50)\\n\\n# Offerings\\noffering1 = Offering(student_id=1, course_id=1, charge=100)\\noffering2 = Offering(student_id=1, course_id=2, charge=150)\\noffering3 = Offering(student_id=1, course_id=3, charge=50)\\noffering4 = Offering(student_id=2, course_id=1, charge=50)\\noffering5 = Offering(student_id=2, course_id=4, charge=50)\\noffering6 = Offering(student_id=3, course_id=2, charge=150)\\noffering7 = Offering(student_id=3, course_id=3, charge=100)\\noffering8 = Offering(student_id=4, course_id=4, charge=50)\\n\",\n    \"name\": \"EducationLogic\"\n}"}]}
